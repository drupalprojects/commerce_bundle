<?php

/**
 * @file
 * Provides product bundles for Drupal Commerce
 */

module_load_include('inc', 'commerce_bundle', 'includes/commerce_bundle.field');

/**
 * Implements hook_views_api().
 */
function commerce_bundle_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'commerce_bundle') . '/includes/views',
  );
}

/**
 * Retuns an array of bundle line item types
 */
function commerce_bundle_line_item_types() {
  $types = array();

  foreach (commerce_line_item_types() as $type => $line_item_type) {
    if (!empty($line_item_type['product']) && !empty($line_item_type['bundle'])) {
      $types[] = $type;
    }
  }

  return $types;
}

/**
 * Implements hook_commerce_bundle_item_can_delete().
 */
function commerce_bundle_commerce_bundle_item_can_delete($entity) {
  $line_item_types = commerce_bundle_line_item_types();
  if (empty($line_item_types)) {
    return TRUE;
  }

  // Use EntityFieldQuery to look for line items referencing this bundle item
  // and do not allow the delete to occur if one exists.
  $query = new EntityFieldQuery();

  $query
    ->addTag('commerce_bundle_commerce_bundle_item_can_delete')
    ->entityCondition('entity_type', 'commerce_line_item', '=')
    ->entityCondition('bundle', commerce_bundle_line_item_types(), 'IN')
    ->fieldCondition('commerce_bundle_item', 'target_id', $entity->item_id, '=')
    ->count();

  return $query->execute() == 0;
}

/**
 * Implements hook_commerce_line_item_type_info().
 */
function commerce_bundle_commerce_line_item_type_info() {
  $line_item_types = array();

  $line_item_types['commerce_bundle_line_item'] = array(
    'type' => 'commerce_bundle_line_item',
    'name' => t('Bundle Line Item'),
    'description' => t('References Bundle Groups, Bundle Items, and Bundle Products.'),
    'product' => TRUE,
    'bundle' => TRUE,
    'add_form_submit_value' => t('Add bundle'),
    'base' => 'commerce_product_line_item',
    'callbacks' => array(
      'title' => 'commerce_bundle_line_item_title',
    ),
  );

  return $line_item_types;
}

/**
 * Returns a title of the bundle line item for use in Views.
 *
 * @param $line_item
 *   The bundle line item object whose title should be returned.
 *
 * @return
 *  The appropriate title depending on if the line item is a control row or not.
 */
function commerce_bundle_line_item_title($line_item) {
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);

  // Currently, just return the product's title.  However, in the future replace
  // this with extra bundle info.
  if ($product = $line_item_wrapper->commerce_product->value()) {
    return check_plain($product->title);
  }
}

/**
 * Generates unique config ids used to group similar line items.
 *
 * @param $line_items
 *   An array of line item objects.
 *
 * @return
 *   An array keyed by bundle configuration IDs with values of keys from the
 *   given line items array.
 */
function commerce_bundle_line_item_get_bundle_configs($line_items) {
  $config_field_names = array(
    'commerce_bundle_id',
    'commerce_bundle_group_id',
    'commerce_bundle_item_id',
    'commerce_product',
  );

  $bundles = array();
  foreach ($line_items as $delta => $line_item) {
    $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
    foreach ($config_field_names as $config_field_name) {
      if (!isset($line_item_wrapper->{$config_field_name})) {
        continue 2;
      }
    }

    $bundle_id = NULL;
    $config_ids = array();
    foreach ($config_field_names as $config_field_name) {
      $entity_id = $line_item_wrapper->{$config_field_name}->raw();
      if (empty($entity_id)) {
        continue 2;
      }
      if ($config_field_name == 'commerce_bundle_id') {
        $bundle_id = $entity_id;
      }

      $config_ids[$config_field_name] = $entity_id;
    }

    if ($bundle_id) {
      $bundles[$bundle_id][$delta] = implode('_', $config_ids);
    }
  }

  $return = array();
  if (!empty($bundles)) {
    foreach ($bundles as $bundle_id => $configs) {
      // Hash entity ids representing the config.
      $hash = drupal_hash_base64(implode('_', array_values($configs)));

      // Store line item ids;
      $return[$hash] = array();
      foreach ($configs as $delta => $combined_config_ids) {
        $return[$hash][$delta] = $line_items[$delta];
      }
    }
  }

  return $return;
}

/**
 * Creates a new bundle product line item populated with the proper product values.
 *
 * @param $bundle_item
 *   The full loaded bundle item entity.
 * @param $group
 *   The fully loaded product group.
 * @param $bundler
 *   The fully loaded entity bundling all the product groups.
 * @param $quantity
 *   The quantity to set for the product.
 * @param $order_id
 *   The ID of the order the line item belongs to (if available).
 * @param $data
 *   A data array to set on the new line item. The following information in the
 *   data array may be used on line item creation:
 *   - $data['context']['display_path']: if present will be used to set the line
 *     item's display_path field value.
 * @param $type
 *   The type of product line item to create. Must be a product line item as
 *   defined in the line item type info array, and the line item type must
 *   include the expected product related fields. Defaults to the base product
 *   line item type defined by the Product Reference module.
 *
 * @return
 *   The fully loaded line item populated with the product data as specified.
 */
function commerce_bundle_product_line_item_new($bundle_item, $group, $bundler, $quantity = 1, $order_id = 0, $data = array(), $type = 'commerce_bundle_line_item') {
  // Ensure a default product line item type.
  if (empty($type)) {
    $type = 'commerce_bundle_line_item';
  }

  // Create the new line item.
  $line_item = entity_create('commerce_line_item', array(
    'type' => $type,
    'order_id' => $order_id,
    'quantity' => $quantity,
    'data' => $data,
  ));

  // Populate it with the entity information.
  commerce_bundle_product_line_item_populate($line_item, $bundler, $group, $bundle_item);

  // Return the line item.
  return $line_item;
}

/**
 * Populates an existing bundle product line item with the product and quantity data.
 *
 * @param $line_item
 *   The fully loaded line item object, populated by reference.
 * @param $bundler
 *   The fully loaded entity bundling all the product groups.
 * @param $group
 *   The fully loaded product group.
 * @param $bundle_item
 *   The fully loaded bundle item entity.
 */
function commerce_bundle_product_line_item_populate($line_item, $bundler, $group, $bundle_item) {
  // Wrap the entities.
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  $group_wrapper = entity_metadata_wrapper('commerce_product', $group);
  $bundle_item_wrapper = entity_metadata_wrapper('commerce_bundle_item', $bundle_item);

  // Set the bundler reference - lazy set to allow any entity type.
  if (isset($line_item_wrapper->commerce_bundle_id)) {
    $line_item_wrapper->commerce_bundle_id = $bundler;
  }

  // Set the product group reference.
  if (isset($line_item_wrapper->commerce_bundle_group_id)) {
    $line_item_wrapper->commerce_bundle_group_id = $group;
  }

  // Set the bundle item reference.
  if (isset($line_item_wrapper->commerce_bundle_item_id)) {
    $line_item_wrapper->commerce_bundle_item_id = $bundle_item->item_id;
  }

  // Set the product reference.
  $product_wrapper = $bundle_item_wrapper->commerce_bundle_product;
  $product = $product_wrapper->value();
  $line_item_wrapper->commerce_product = $product->product_id;

  // Set the label to be the product SKU.
/** @todo: should label be set to something indicating bundle? **/
  $line_item->line_item_label = $product->sku;

  // Set unit quantity and update line item quantity.
  $unit_quantity = NULL;
  if (isset($group_wrapper->commerce_bundle_unit_quantity) &&
      isset($line_item_wrapper->commerce_bundle_unit_quantity)) {
    // Set the unit quanity.
    $unit_quantity = $group_wrapper->commerce_bundle_unit_quantity->value();
    $line_item_wrapper->commerce_bundle_unit_quantity = $unit_quantity;

    // Update line item quantity.
    $line_item->quantity *= (int) $unit_quantity;
  }

  // Add the display URI if specified.
  if (!empty($line_item->data['context']['display_path'])) {
    $line_item_wrapper->commerce_display_path = $line_item->data['context']['display_path'];
  }
  else {
    $line_item_wrapper->commerce_display_path = '';
  }

  // Calculate the bundle unit price on the line item.
  $bundle_unit_price = array();
  if ($group_wrapper->commerce_price->value()) {
    $bundle_unit_price = commerce_price_wrapper_value($group_wrapper, 'commerce_price', TRUE);
  }
  elseif ($bundle_item_wrapper->commerce_bundle_price->value()) {
    $bundle_unit_price = commerce_price_wrapper_value($bundle_item_wrapper, 'commerce_bundle_price', TRUE);
  }
  else {
    $bundle_unit_price = commerce_price_wrapper_value($product_wrapper, 'commerce_price', TRUE);
  }

  // TODO: add an alter hook for bundle price ?

  // Set the unit price on the line item object if the product has a value in
  // its commerce_price field.
  $line_item->commerce_unit_price = $product->commerce_price;

  if (!is_null($line_item_wrapper->commerce_unit_price->value())) {
    // Add the base price to the components array.
    if (!commerce_price_component_load($line_item_wrapper->commerce_unit_price->value(), 'base_price')) {
      $line_item_wrapper->commerce_unit_price->data = commerce_price_component_add(
        $line_item_wrapper->commerce_unit_price->value(),
        'base_price',
        $line_item_wrapper->commerce_unit_price->value(),
        TRUE
      );
    }
  }


  // Set bundle unit price as a discount.
  if (isset($bundle_unit_price['amount'])) {
    $unit_price = commerce_price_wrapper_value($line_item_wrapper, 'commerce_unit_price', TRUE);

    // Calculate the updated amount and create a price array representing the
    // difference between it and the current amount.
    $current_amount = $unit_price['amount'];

    // Calculate the updated amount and create a price array representing the
    // difference between it and the current amount.
    $current_amount = $unit_price['amount'];
    $updated_amount = $bundle_unit_price['amount'];

    $difference = array(
      'amount' => $bundle_unit_price['amount'] - $current_amount,
      'currency_code' => $unit_price['currency_code'],
      'data' => array(),
    );

    // Set the amount of the unit price and add the difference as a component.
    $line_item_wrapper->commerce_unit_price->amount = $updated_amount;

    $line_item_wrapper->commerce_unit_price->data = commerce_price_component_add(
      $line_item_wrapper->commerce_unit_price->value(),
      'discount',
      $difference,
      TRUE
    );
  }
}

/**
 * Builds an appropriate cart form ID based on the product groups on the form.
 *
 * @see commerce_bundle_forms().
 */
function commerce_bundle_add_to_cart_form_id($group_ids) {
  // Make sure the length of the form id is limited.
  $data = implode('_', $group_ids);

  if (strlen($data) > 50) {
    $data = drupal_hash_base64($data);
  }

  return 'commerce_bundle_add_to_cart_form_' . $data;
}

/**
 * Implements hook_forms().
 *
 * To provide distinct form IDs for add to cart forms, the product IDs
 * referenced by the form are appended to the base ID,
 * commerce_cart_add_to_cart_form. When such a form is built or submitted, this
 * function will return the proper callback function to use for the given form.
 */
function commerce_bundle_forms($form_id, $args) {
  $forms = array();

  // Construct a valid cart form ID from the arguments.
  if (strpos($form_id, 'commerce_bundle_add_to_cart_form_') === 0) {
    $forms[$form_id] = array(
      'callback' => 'commerce_bundle_add_to_cart_form',
    );
  }

  return $forms;
}

/**
 * Builds an Add to Cart form for a set of products.
 *
 * @param $line_items
 *   An array of fully formed bundle product line itema whose data will be
 *   used in the following ways by the form:
 *   - $line_item->data['context']['add_to_cart_combine']: a boolean indicating
 *     whether or not to attempt to combine the product added to the cart with
 *     existing line items of matching fields.
 *   - $line_item->data['context']['show_single_product_attributes']: a boolean
 *     indicating whether or not product attribute fields with single options
 *     should be shown on the Add to Cart form.
 *   - $line_item->quantity: the default value for the quantity widget if
 *     included (determined by the $show_quantity parameter).
 *   - $line_item->commerce_product: the value of this field will be used as the
 *     default product ID when the form is built for multiple products.
 *   The line item's data array will be used on submit to set the data array of
 *   the product line item created by the form.
 * @param $show_quantity
 *   Boolean indicating whether or not to show the quantity widget; defaults to
 *   FALSE resulting in a hidden field holding the quantity.
 * @param $context
 *   Information on the context of the form's placement, allowing it to update
 *   product fields on the page based on the currently selected default product.
 *   Should be an associative array containing the following keys:
 *   - class_prefix: a prefix used to target HTML containers for replacement
 *     with rendered fields as the default product is updated. For example,
 *     nodes display product fields in their context wrapped in spans with the
 *     class node-#-product-field_name.  The class_prefix for the add to cart
 *     form displayed on a node would be node-# with this form's AJAX refresh
 *     adding the suffix -product-field_name.
 *   - view_mode: a product view mode that tells the AJAX refresh how to render
 *     the replacement fields.
 *   If no context is specified, AJAX replacement of rendered fields will not
 *   happen. This parameter only affects forms containing multiple products.
 *
 * @return
 *   The form array.
 */
function commerce_bundle_add_to_cart_form($form, &$form_state, $line_items, $show_quantity = FALSE, $default_quantity = 1, $context = array()) {
  global $user;

  // Store the context in the form state for use during AJAX refreshes.
  $form_state['context'] = $context;

  // Store the line item passed to the form builder for reference on submit.
  $form_state['line_items'] = &$line_items;
dpm($line_items, '$line_items from bundle line new()');
  // Add a generic class ID.
  $form['#attributes']['class'][] = drupal_html_class('commerce-bundle-add-to-cart');
  $form['#attributes']['class'][] = drupal_html_class('commerce-add-to-cart');

  // Store the customer uid in the form so other modules can override with a
  // selection widget if necessary.
  $form['uid'] = array(
    '#type' => 'value',
    '#value' => $user->uid,
  );

  // Add container for all product groups.
  $form['product_groups'] = array(
    '#type' => 'container',
  );
  $groups_container = &$form['product_groups'];

  // Process bundle configurations.
  $bundle_configs = commerce_bundle_line_item_get_bundle_configs($line_items);
  foreach ($bundle_configs as $bundle_config_id => $bundle_config_line_items) {
    foreach ($bundle_config_line_items as $line_item) {
      $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
      if (isset($line_item_wrapper->commerce_bundle_config_id)) {
        $line_item_wrapper->commerce_bundle_config_id = $bundle_config_id;
      }
    }
  }

  // Build attribute forms per product group.
  $group_ids = array();
  foreach ($line_items as $line_item) {
    $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
    if (!isset($line_item_wrapper->commerce_bundle_group_id)) {
      continue;
    }

    $group_id = $line_item_wrapper->commerce_bundle_group_id->raw();
    $group_ids[] = $line_item_wrapper->commerce_bundle_group_id->raw();

    $groups_container['product_group_' . $group_id] = array(
      '#type' => 'container',
      '#tree' => TRUE,
    );
    $group_form = &$groups_container['product_group_' . $group_id];
    $group_form = commerce_bundle_line_item_attribute_form($line_item, $group_form, $form_state);
  }
  unset($group_form);

  // Store the form ID as a class of the form to avoid the incrementing form ID
  // from causing the AJAX refresh not to work.
  $form['#attributes']['class'][] = drupal_html_class(commerce_bundle_add_to_cart_form_id($group_ids));

  // Render the quantity field as either a textfield if shown or a hidden
  // field if not.
  if ($show_quantity) {
    $form['quantity'] = array(
      '#type' => 'textfield',
      '#title' => t('Quantity'),
      '#default_value' => $default_quantity,
      '#datatype' => 'integer',
      '#size' => 5,
      '#weight' => 45,
    );
  }
  else {
    $form['quantity'] = array(
      '#type' => 'hidden',
      '#value' => $default_quantity,
      '#datatype' => 'integer',
      '#weight' => 45,
    );
  }


  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Add to cart'),
    '#weight' => 50,
  );

  // Add the handlers manually since we're using hook_forms() to associate this
  // form with form IDs based on the $product_ids.
  $form['#validate'][] = 'commerce_bundle_add_to_cart_form_validate';
  $form['#submit'][] = 'commerce_bundle_add_to_cart_form_submit';

  return $form;
}

/**
 * Form validate handler: validate the bundle and quantity to add to the cart.
 */
function commerce_bundle_add_to_cart_form_validate($form, &$form_state) {
  // Check to ensure the quantity is valid.
  if (!is_numeric($form_state['values']['quantity']) || $form_state['values']['quantity'] <= 0) {
    form_set_error('quantity', t('You must specify a valid quantity to add to the cart.'));
  }

  // If the custom data type attribute of the quantity element is integer,
  // ensure we only accept whole number values.
  if ($form['quantity']['#datatype'] == 'integer' &&
    (int) $form_state['values']['quantity'] != $form_state['values']['quantity']) {
    form_set_error('quantity', t('You must specify a whole number for the quantity.'));
  }

  // Validate any line item fields that may have been included on the form.
  if (!empty($form_state['line_items'])) {
    foreach ($form_state['line_items'] as $line_item) {
      $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
      if (!isset($line_item_wrapper->commerce_bundle_group_id)) {
        continue;
      }
/** @todo: throw an error if we dont have a group? **/
      $group_id = $line_item_wrapper->commerce_bundle_group_id->raw();
      if (empty($form['product_groups']['product_group_' . $group_id]) ||
          empty($form_state['values']['product_group_' . $group_id])) {
        continue;
      }

      $group_form = $form['product_groups']['product_group_' . $group_id];
      $group_form_state_values = &$form_state['values']['product_group_' . $group_id];

      // If the attributes matching product selector was used, set the value of the
      // product_id field to match; this will be fixed on rebuild when the actual
      // default product will be selected based on the product selector value.
      if (!empty($group_form_state_values['attributes']['product_select'])) {
        form_set_value($group_form['product_id'], $group_form_state_values['attributes']['product_select'], $form_state);
      }

/** @todo: pass in nest form state? or does this figure it out ***/
      if (!empty($group_form['line_item_fields'])) {
        field_attach_form_validate('commerce_line_item', $line_item, $group_form['line_item_fields'], $form_state);
      }
    }
  }
}

/**
 * Form submit handler: add the selected bundle to the cart.
 */
function commerce_bundle_add_to_cart_form_submit($form, &$form_state) {
  if (empty($form_state['line_items'])) {
    return;
  }

  $add_to_cart_deltas = array();
  $bundle_quantity = isset($form_state['values']['quantity']) ? $form_state['values']['quantity'] : 1;
  foreach ($form_state['line_items'] as $state_line_item_delta => &$state_line_item) {
    // If the line item passed to the function is new...
    if (empty($state_line_item->line_item_id)) {
      $state_line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $state_line_item);
      if (!isset($state_line_item_wrapper->commerce_bundle_id) ||
          !isset($state_line_item_wrapper->commerce_bundle_group_id) ||
          !isset($state_line_item_wrapper->commerce_bundle_item_id)) {
        continue;
      }

      $group_id = $state_line_item_wrapper->commerce_bundle_group_id->raw();
      if (empty($form_state['values']['product_group_' . $group_id])) {
        continue;
      }
      $group_form_state_values = &$form_state['values']['product_group_' . $group_id];
      $group_form = $form['product_groups']['product_group_' . $group_id];

      $product_id = $group_form_state_values['product_id'];
      $product = commerce_product_load($product_id);


      $bundler_wrapper = $state_line_item_wrapper->commerce_bundle_id;
      $group_wrapper = $state_line_item_wrapper->commerce_bundle_group_id;
      $bundle_item_wrapper = $state_line_item_wrapper->commerce_bundle_item_id;

      // Create the new bundle product line item of the same type.
      $line_item = commerce_bundle_product_line_item_new(
        $bundle_item_wrapper->value(),
        $group_wrapper->value(),
        $bundler_wrapper->value(),
        $bundle_quantity,
        0,
        $state_line_item->data,
        $state_line_item->type
      );

      // Allow modules to prepare this as necessary. This hook is defined by the
      // Product Pricing module.
      drupal_alter('commerce_product_calculate_sell_price_line_item', $line_item);

      // Remove line item field values the user didn't have access to modify.
      if (!empty($group_form_state_values['line_item_fields'])) {
        foreach ($group_form_state_values['line_item_fields'] as $field_name => $value) {
          // Note that we're checking the Commerce Cart settings that we inserted
          // into this form element array back when we built the form. This means a
          // module wanting to alter a line item field widget to be available must
          // update both its form element's #access value and the field_access value
          // of the #commerce_cart_settings array.
          if (empty($form['line_item_fields'][$field_name]['#commerce_cart_settings']['field_access'])) {
            unset($group_form_state_values['line_item_fields'][$field_name]);
          }
        }
      }

      // Unset the line item field values array if it is now empty.
      if (empty($group_form_state_values['line_item_fields'])) {
        unset($group_form_state_values['line_item_fields']);
      }

      // Add field data to the line item.
      if (!empty($group_form['line_item_fields'])) {
        field_attach_submit('commerce_line_item', $line_item, $group_form['line_item_fields'], $form_state);
      }

      // Process the unit price through Rules so it reflects the user's actual
      // purchase price.
      rules_invoke_event('commerce_product_calculate_sell_price', $line_item);

      // Only attempt an Add to Cart if the line item has a valid unit price.
      $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);

      if (!is_null($line_item_wrapper->commerce_unit_price->value())) {
        // Add the product to the specified shopping cart.
        $state_line_item = $line_item;
        $add_to_cart_deltas[] = $state_line_item_delta;
      }
      else {
        drupal_set_message(t('%title could not be added to your cart.', array('%title' => entity_label($bundler_wrapper->type(), $bundler_wrapper->value()))), 'error');
        return;
      }
    }
  }
  unset($state_line_item);

  // Set bundle configuration.
  $line_item_configs_updated = array();
  $bundle_configs = commerce_bundle_line_item_get_bundle_configs($form_state['line_items']);
  foreach ($bundle_configs as $bundle_config_id => $bundle_config_line_items) {
    foreach ($bundle_config_line_items as $line_item) {
      $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
      if (isset($line_item_wrapper->commerce_bundle_config_id)) {
        $line_item_wrapper->commerce_bundle_config_id = $bundle_config_id;

        if (isset($line_item->line_item_id)) {
          $line_item_configs_updated[] = $line_item->line_item_id;
        }
      }
    }
  }

  // Save line items.
  foreach ($form_state['line_items'] as $delta => $line_item) {
    if (in_array($delta, $add_to_cart_deltas)) {
      // Add new line items to the cart.
      $form_state['line_items'][$delta] = commerce_cart_product_add(
        $form_state['values']['uid'],
        $line_item,
        isset($line_item->data['context']['add_to_cart_combine']) ? $line_item->data['context']['add_to_cart_combine'] : TRUE
      );
    }
    elseif (isset($line_item->line_item_id) &&
            in_array($line_item->line_item_id, $line_item_configs_updated)) {
      // Update existing line items.
      commerce_line_item_save($line_item);

      // Clear the line item cache so that updates show on next load..
      entity_get_controller('commerce_line_item')->resetCache(array($line_item->line_item_id));
    }
  }
}

/**
 * Returns the attribute form for a given bundle line item.
 *
 * @param $line_item
 *   The bundle line item.
 * @param $form
 *   The form array.
 * @param $form_state
 *   The form state.
 *
 * @return
 *   An attribute form array
 */
function commerce_bundle_line_item_attribute_form($line_item, $form, &$form_state) {
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  if (!isset($line_item_wrapper->commerce_bundle_group_id)) {
    return $form;
  }

  $group_id = $line_item_wrapper->commerce_bundle_group_id->raw();
  $group = $line_item_wrapper->commerce_bundle_group_id->value();
  $group_wrapper = entity_metadata_wrapper('commerce_product', $group);
  if (!isset($group_wrapper->commerce_bundle_items)) {
    return $form;
  }

  $group_product_ids = array();
  foreach ($group_wrapper->commerce_bundle_items as $bundle_item_wrapper) {
    // Skip disabled bundle items.
    if (!$bundle_item_wrapper->status->value()) {
      continue;
    }

    if (isset($bundle_item_wrapper->commerce_bundle_product) &&
        ($bundle_item_product_id = $bundle_item_wrapper->commerce_bundle_product->raw())) {
      $group_product_ids[$bundle_item_product_id] = $bundle_item_product_id;
    }
  }

  if (empty($group_product_ids)) {
    return $form;
  }

  // @todo: orginal cart form needed this, but bundle line items don't.
  $line_item->data['context']['product_ids'] = $group_product_ids;

  $form['product_id'] = array(
    '#type' => 'select',
    '#title' => 'test product',
    '#default_value' => reset($group_product_ids),
    '#options' => drupal_map_assoc($group_product_ids),
    '#disabled' => TRUE,
  );

  return $form;
}
